[{"engine_name":"structure","fingerprint":"f8ccebfc07d1a0c9fa77b6325a61b82c","categories":["Complexity"],"check_name":"method_complexity","content":{"body":"# Cognitive Complexity\nCognitive Complexity is a measure of how difficult a unit of code is to intuitively understand. Unlike Cyclomatic Complexity, which determines how difficult your code will be to test, Cognitive Complexity tells you how difficult your code will be to read and comprehend.\n\n### A method's cognitive complexity is based on a few simple rules:\n* Code is not considered more complex when it uses shorthand that the language provides for collapsing multiple statements into one\n* Code is considered more complex for each \"break in the linear flow of the code\"\n* Code is considered more complex when \"flow breaking structures are nested\"\n\n### Further reading\n* [Cognitive Complexity docs](https://docs.codeclimate.com/v1.0/docs/cognitive-complexity)\n* [Cognitive Complexity: A new way of measuring understandability](https://www.sonarsource.com/docs/CognitiveComplexity.pdf)\n"},"description":"Method `refresh_baseline_if_configured` has a Cognitive Complexity of 13 (exceeds 10 allowed). Consider refactoring.","location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":7,"end":39}},"other_locations":[],"remediation_points":450000,"severity":"minor","type":"issue"},
{"engine_name":"structure","fingerprint":"4890c3e24aa5f22bc928ccddd6a60a14","categories":["Complexity"],"check_name":"method_lines","content":{"body":""},"description":"Method `sort_issues` has 26 lines of code (exceeds 25 allowed). Consider refactoring.","location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":33,"end":73}},"other_locations":[],"remediation_points":624000,"severity":"minor","type":"issue"},
{"engine_name":"structure","fingerprint":"5989a7d02618f9eba49266f1c5473861","categories":["Complexity"],"check_name":"argument_count","content":{"body":""},"description":"Method `print_category` has 5 arguments (exceeds 4 allowed). Consider refactoring.","location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":20,"end":20}},"other_locations":[],"remediation_points":375000,"severity":"minor","type":"issue"},
{"engine_name":"structure","fingerprint":"79ec8f3ef3737357ed2c43ab0a065ef3","categories":["Complexity"],"check_name":"method_complexity","content":{"body":"# Cognitive Complexity\nCognitive Complexity is a measure of how difficult a unit of code is to intuitively understand. Unlike Cyclomatic Complexity, which determines how difficult your code will be to test, Cognitive Complexity tells you how difficult your code will be to read and comprehend.\n\n### A method's cognitive complexity is based on a few simple rules:\n* Code is not considered more complex when it uses shorthand that the language provides for collapsing multiple statements into one\n* Code is considered more complex for each \"break in the linear flow of the code\"\n* Code is considered more complex when \"flow breaking structures are nested\"\n\n### Further reading\n* [Cognitive Complexity docs](https://docs.codeclimate.com/v1.0/docs/cognitive-complexity)\n* [Cognitive Complexity: A new way of measuring understandability](https://www.sonarsource.com/docs/CognitiveComplexity.pdf)\n"},"description":"Method `calculate_issues_in_changed_files` has a Cognitive Complexity of 24 (exceeds 10 allowed). Consider refactoring.","location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":22,"end":54}},"other_locations":[],"remediation_points":1550000,"severity":"minor","type":"issue"},
{"name":"ruby.parse.succeeded","type":"measurement","value":7,"engine_name":"structure"},
{"engine_name":"reek","fingerprint":"054589dd54a8aef188941b688d099978","type":"issue","check_name":"IrresponsibleModule","description":"CodeclimateDiff::CodeclimateWrapper has no descriptive comment","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/codeclimate_wrapper.rb","lines":{"begin":7,"end":7}},"remediation_points":350000,"content":{"body":"Classes and modules are the units of reuse and release. It is therefore considered good practice to annotate every class and module with a brief comment outlining its responsibilities.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  # Do things...\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 1 warning:\n  [1]:Dummy has no descriptive comment (IrresponsibleModule)\n```\n\nFixing this is simple - just an explaining comment:\n\n```Ruby\n# The Dummy class is responsible for ...\nclass Dummy\n  # Do things...\nend\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"0ab3c6e125bef6686b3c821c59933e08","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured calls 'CodeclimateDiff.configuration' 6 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":8,"end":22}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"585621642e3917aabb584a8dee9dc5b9","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured calls 'CodeclimateDiff.configuration[\"gitlab\"]' 5 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":8,"end":22}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"a90c8153eeb16896f80233d15786037a","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured calls 'puts \"Using current baseline.\"' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":33,"end":38}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"4dade4b82ae3a3c900dd5cbd4baa48c0","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured calls 'response.body' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":29,"end":32}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"eb7c72ed624bdafbdbfee6ceed64db54","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured calls 'response.code' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":28,"end":32}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"f54441e8533c9bf76e64b72596931f02","type":"issue","check_name":"IrresponsibleModule","description":"CodeclimateDiff::Downloader has no descriptive comment","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":6,"end":6}},"remediation_points":350000,"content":{"body":"Classes and modules are the units of reuse and release. It is therefore considered good practice to annotate every class and module with a brief comment outlining its responsibilities.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  # Do things...\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 1 warning:\n  [1]:Dummy has no descriptive comment (IrresponsibleModule)\n```\n\nFixing this is simple - just an explaining comment:\n\n```Ruby\n# The Dummy class is responsible for ...\nclass Dummy\n  # Do things...\nend\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"d2ddd39e281760ccf0b0918fe08e7e7c","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured has approx 19 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":7,"end":7}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"211287e4b5857d557ac53a56826d6fa0","type":"issue","check_name":"UncommunicativeVariableName","description":"CodeclimateDiff::Downloader#self.refresh_baseline_if_configured has the variable name 'e'","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/downloader.rb","lines":{"begin":36,"end":36}},"remediation_points":150000,"content":{"body":"An `Uncommunicative Variable Name` is a variable name that doesn't communicate its intent well enough.\n\nPoor names make it hard for the reader to build a mental picture of what's going on in the code. They can also be mis-interpreted; and they hurt the flow of reading, because the reader must slow down to interpret the names.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"6387eea8958bb1f9b03eb1a4d1a7d3d7","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'issue[\"description\"] == issue_to_match[\"description\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":10,"end":21}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"26e97835cc4b485f5758c3fcf6c9aaea","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'issue[\"description\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":10,"end":21}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"22d5da8bce52124b5a9c808004f82019","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'issue[\"fingerprint\"] == issue_to_match[\"fingerprint\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":8,"end":20}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"cc510276d86e62d3aaf8388d5bfa2b19","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'issue[\"fingerprint\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":8,"end":20}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"0b23ee28cb8bdc33b6f2f06a482b5267","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'issue_to_match[\"description\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":10,"end":21}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"30a514924733303a35f7ae8c8de71a95","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'issue_to_match[\"fingerprint\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":8,"end":20}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"e1a894e2e680a8948d6a5bee61911741","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'list.delete_at(index)' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":14,"end":25}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"2fefd889dbaf81b11b2bea400c8d6deb","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list calls 'list.index' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":7,"end":19}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"ca6ea3faac869baf424f72669048c899","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.sort_issues calls 'baseline_issues.count' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":50,"end":53}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"fe0d4f54334ad664a42b1018ae44a8ca","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.sort_issues calls 'current_issues.count' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":50,"end":53}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"26083f936211b5167cc5f6809b9c9ade","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.sort_issues calls 'issue[\"fingerprint\"] == fingerprint' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":47,"end":48}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"e879665bca8ca2a6bc3f789248ff8b39","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::IssueSorter#self.sort_issues calls 'issue[\"fingerprint\"]' 3 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":44,"end":48}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"d90684590df5d9e0fe73c8b42d49fb87","type":"issue","check_name":"IrresponsibleModule","description":"CodeclimateDiff::IssueSorter has no descriptive comment","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":4,"end":4}},"remediation_points":350000,"content":{"body":"Classes and modules are the units of reuse and release. It is therefore considered good practice to annotate every class and module with a brief comment outlining its responsibilities.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  # Do things...\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 1 warning:\n  [1]:Dummy has no descriptive comment (IrresponsibleModule)\n```\n\nFixing this is simple - just an explaining comment:\n\n```Ruby\n# The Dummy class is responsible for ...\nclass Dummy\n  # Do things...\nend\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"980375b6536d455e110ca4c16fb8385a","type":"issue","check_name":"NestedIterators","description":"CodeclimateDiff::IssueSorter#self.sort_issues contains iterators nested 2 deep","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":47,"end":61}},"remediation_points":500000,"content":{"body":"A `Nested Iterator` occurs when a block contains another block.\n\n## Example\n\nGiven\n\n```Ruby\nclass Duck\n  class \u003c\u003c self\n    def duck_names\n      %i!tick trick track!.each do |surname|\n        %i!duck!.each do |last_name|\n          puts \"full name is #{surname} #{last_name}\"\n        end\n      end\n    end\n  end\nend\n```\n\nReek would report the following warning:\n\n```\ntest.rb -- 1 warning:\n  [5]:Duck#duck_names contains iterators nested 2 deep (NestedIterators)\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"c43a4fd2dc6f9f2900cf0b0a0702294e","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::IssueSorter#self.remove_closest_match_from_list has approx 9 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":5,"end":5}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"c8711ff1c512044d0e938787698e5f45","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::IssueSorter#self.sort_issues has approx 22 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/issue_sorter.rb","lines":{"begin":33,"end":33}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"7b8cb5858d38666042143f4f0ad0e173","type":"issue","check_name":"ControlParameter","description":"CodeclimateDiff::ResultPrinter#self.print_category is controlled by argument 'color'","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":23,"end":23}},"remediation_points":500000,"content":{"body":"`Control Parameter` is a special case of `Control Couple`\n\n## Example\n\nA simple example would be the \"quoted\" parameter in the following method:\n\n```Ruby\ndef write(quoted)\n  if quoted\n    write_quoted @value\n  else\n    write_unquoted @value\n  end\nend\n```\n\nFixing those problems is out of the scope of this document but an easy solution could be to remove the \"write\" method alltogether and to move the calls to \"write_quoted\" / \"write_unquoted\" in the initial caller of \"write\".\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"83771ef70121c9192872a09a66ee7b0c","type":"issue","check_name":"ControlParameter","description":"CodeclimateDiff::ResultPrinter#self.print_result is controlled by argument 'show_preexisting'","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":52,"end":52}},"remediation_points":500000,"content":{"body":"`Control Parameter` is a special case of `Control Couple`\n\n## Example\n\nA simple example would be the \"quoted\" parameter in the following method:\n\n```Ruby\ndef write(quoted)\n  if quoted\n    write_quoted @value\n  else\n    write_unquoted @value\n  end\nend\n```\n\nFixing those problems is out of the scope of this document but an easy solution could be to remove the \"write\" method alltogether and to move the calls to \"write_quoted\" / \"write_unquoted\" in the initial caller of \"write\".\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"f188df8774fe06f10f92ea3ced203a90","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_issues calls 'issue[\"check_name\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":36,"end":43}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"da9c16763266a2ee7c4acd27b473f431","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_issues calls 'issue[\"engine_name\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":36,"end":42}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"e9462c1d7525075446ba64f4bf4ddc2b","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_issues calls 'issue[\"severity\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":36,"end":44}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"a6d4b886f1137834a7895847fda2a405","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_issues_in_category calls 'issue[\"location\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":10,"end":11}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"c426eed4fc2a91238bf2a338dc0ac631","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_result calls 'fixed_issues.count' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":71,"end":72}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"9f6643562758be7d65fc46249ba74212","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_result calls 'new_issues.count' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":63,"end":64}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"66c9f93f83039d5ff8b90e5f5f57156a","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::ResultPrinter#self.print_result calls 'preexisting_issues.count' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":54,"end":55}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"524d4bedfc2cef6b38a753be561516ef","type":"issue","check_name":"IrresponsibleModule","description":"CodeclimateDiff::ResultPrinter has no descriptive comment","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":7,"end":7}},"remediation_points":350000,"content":{"body":"Classes and modules are the units of reuse and release. It is therefore considered good practice to annotate every class and module with a brief comment outlining its responsibilities.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  # Do things...\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 1 warning:\n  [1]:Dummy has no descriptive comment (IrresponsibleModule)\n```\n\nFixing this is simple - just an explaining comment:\n\n```Ruby\n# The Dummy class is responsible for ...\nclass Dummy\n  # Do things...\nend\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"b96b36b5b941ac84266107f82a75ecb6","type":"issue","check_name":"LongParameterList","description":"CodeclimateDiff::ResultPrinter#self.print_category has 5 parameters","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":20,"end":20}},"remediation_points":500000,"content":{"body":"A `Long Parameter List` occurs when a method has a lot of parameters.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  def long_list(foo,bar,baz,fling,flung)\n    puts foo,bar,baz,fling,flung\n  end\nend\n```\n\nReek would report the following warning:\n\n```\ntest.rb -- 1 warning:\n  [2]:Dummy#long_list has 5 parameters (LongParameterList)\n```\n\nA common solution to this problem would be the introduction of parameter objects.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"24256875bc239c7ee72e7bf5162a5cf1","type":"issue","check_name":"NestedIterators","description":"CodeclimateDiff::ResultPrinter#self.print_issues contains iterators nested 2 deep","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":41,"end":41}},"remediation_points":500000,"content":{"body":"A `Nested Iterator` occurs when a block contains another block.\n\n## Example\n\nGiven\n\n```Ruby\nclass Duck\n  class \u003c\u003c self\n    def duck_names\n      %i!tick trick track!.each do |surname|\n        %i!duck!.each do |last_name|\n          puts \"full name is #{surname} #{last_name}\"\n        end\n      end\n    end\n  end\nend\n```\n\nReek would report the following warning:\n\n```\ntest.rb -- 1 warning:\n  [5]:Duck#duck_names contains iterators nested 2 deep (NestedIterators)\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"dba788bce2d4037f442a07834141f748","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::ResultPrinter#self.print_call_to_action has approx 7 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":79,"end":79}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"847c6524aee19aaaa5c9f75d2af55034","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::ResultPrinter#self.print_issues has approx 10 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":35,"end":35}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"0e1b58c41f946011380b520b782497f6","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::ResultPrinter#self.print_issues_in_category has approx 7 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":8,"end":8}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"659011304f57ba6821ee6ecd179e2fe3","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::ResultPrinter#self.print_result has approx 12 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/result_printer.rb","lines":{"begin":51,"end":51}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"eebfb3495de5ce6c32cdbdedd3733169","type":"issue","check_name":"BooleanParameter","description":"CodeclimateDiff::Runner#self.run_diff_on_branch has boolean parameter 'always_analyze_all_files'","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":74,"end":74}},"remediation_points":500000,"content":{"body":"`Boolean Parameter` is a special case of `Control Couple`, where a method parameter is defaulted to true or false. A _Boolean Parameter_ effectively permits a method's caller to decide which execution path to take. This is a case of bad cohesion. You're creating a dependency between methods that is not really necessary, thus increasing coupling.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  def hit_the_switch(switch = true)\n    if switch\n      puts 'Hitting the switch'\n      # do other things...\n    else\n      puts 'Not hitting the switch'\n      # do other things...\n    end\n  end\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 3 warnings:\n  [1]:Dummy#hit_the_switch has boolean parameter 'switch' (BooleanParameter)\n  [2]:Dummy#hit_the_switch is controlled by argument switch (ControlParameter)\n```\n\nNote that both smells are reported, `Boolean Parameter` and `Control Parameter`.\n\n## Getting rid of the smell\n\nThis is highly dependent on your exact architecture, but looking at the example above what you could do is:\n\n* Move everything in the `if` branch into a separate method\n* Move everything in the `else` branch into a separate method\n* Get rid of the `hit_the_switch` method alltogether\n* Make the decision what method to call in the initial caller of `hit_the_switch`\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"f69f9414e9b677df0fe0fa88a56e09e6","type":"issue","check_name":"BooleanParameter","description":"CodeclimateDiff::Runner#self.run_diff_on_branch has boolean parameter 'show_preexisting'","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":74,"end":74}},"remediation_points":500000,"content":{"body":"`Boolean Parameter` is a special case of `Control Couple`, where a method parameter is defaulted to true or false. A _Boolean Parameter_ effectively permits a method's caller to decide which execution path to take. This is a case of bad cohesion. You're creating a dependency between methods that is not really necessary, thus increasing coupling.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  def hit_the_switch(switch = true)\n    if switch\n      puts 'Hitting the switch'\n      # do other things...\n    else\n      puts 'Not hitting the switch'\n      # do other things...\n    end\n  end\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 3 warnings:\n  [1]:Dummy#hit_the_switch has boolean parameter 'switch' (BooleanParameter)\n  [2]:Dummy#hit_the_switch is controlled by argument switch (ControlParameter)\n```\n\nNote that both smells are reported, `Boolean Parameter` and `Control Parameter`.\n\n## Getting rid of the smell\n\nThis is highly dependent on your exact architecture, but looking at the example above what you could do is:\n\n* Move everything in the `if` branch into a separate method\n* Move everything in the `else` branch into a separate method\n* Get rid of the `hit_the_switch` method alltogether\n* Make the decision what method to call in the initial caller of `hit_the_switch`\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"c9d1604f71aa792148908051a6c30a03","type":"issue","check_name":"ControlParameter","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files is controlled by argument 'always_analyze_all_files'","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":26,"end":28}},"remediation_points":500000,"content":{"body":"`Control Parameter` is a special case of `Control Couple`\n\n## Example\n\nA simple example would be the \"quoted\" parameter in the following method:\n\n```Ruby\ndef write(quoted)\n  if quoted\n    write_quoted @value\n  else\n    write_unquoted @value\n  end\nend\n```\n\nFixing those problems is out of the scope of this document but an easy solution could be to remove the \"write\" method alltogether and to move the calls to \"write_quoted\" / \"write_unquoted\" in the initial caller of \"write\".\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"3ff6caf742702e28c65517be34dc4a90","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files calls 'JSON.parse(result)' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":32,"end":45}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"2ace891a3d054cd1d6b178902b0aa4b9","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files calls 'JSON.parse(result).each' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":32,"end":45}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"ec3e2cc4884fd40b46e5fcd406caed9d","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files calls 'changed_file_issues.append(issue)' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":36,"end":48}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"974a71566e027ab872e3496e1782f85a","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files calls 'issue[\"type\"] != \"issue\"' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":33,"end":46}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"ececcf3944ab70f551f1c57fc5f8989f","type":"issue","check_name":"DuplicateMethodCall","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files calls 'issue[\"type\"]' 2 times","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":33,"end":46}},"remediation_points":350000,"content":{"body":"Duplication occurs when two fragments of code look nearly identical, or when two fragments of code have nearly identical effects at some conceptual level.\n\nReek implements a check for _Duplicate Method Call_.\n\n## Example\n\nHere's a very much simplified and contrived example. The following method will report a warning:\n\n```Ruby\ndef double_thing()\n  @other.thing + @other.thing\nend\n```\n\nOne quick approach to silence Reek would be to refactor the code thus:\n\n```Ruby\ndef double_thing()\n  thing = @other.thing\n  thing + thing\nend\n```\n\nA slightly different approach would be to replace all calls of `double_thing` by calls to `@other.double_thing`:\n\n```Ruby\nclass Other\n  def double_thing()\n    thing + thing\n  end\nend\n```\n\nThe approach you take will depend on balancing other factors in your code.\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"cd318842f19b32d930607d78221cf5c5","type":"issue","check_name":"IrresponsibleModule","description":"CodeclimateDiff::Runner has no descriptive comment","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":12,"end":12}},"remediation_points":350000,"content":{"body":"Classes and modules are the units of reuse and release. It is therefore considered good practice to annotate every class and module with a brief comment outlining its responsibilities.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  # Do things...\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 1 warning:\n  [1]:Dummy has no descriptive comment (IrresponsibleModule)\n```\n\nFixing this is simple - just an explaining comment:\n\n```Ruby\n# The Dummy class is responsible for ...\nclass Dummy\n  # Do things...\nend\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"e5fe8233608d51d516fe9c9662f3bce0","type":"issue","check_name":"NestedIterators","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files contains iterators nested 2 deep","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":45,"end":45}},"remediation_points":500000,"content":{"body":"A `Nested Iterator` occurs when a block contains another block.\n\n## Example\n\nGiven\n\n```Ruby\nclass Duck\n  class \u003c\u003c self\n    def duck_names\n      %i!tick trick track!.each do |surname|\n        %i!duck!.each do |last_name|\n          puts \"full name is #{surname} #{last_name}\"\n        end\n      end\n    end\n  end\nend\n```\n\nReek would report the following warning:\n\n```\ntest.rb -- 1 warning:\n  [5]:Duck#duck_names contains iterators nested 2 deep (NestedIterators)\n```\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"545f4e2fbe74902028bcf6c047db975b","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::Runner#self.calculate_changed_filenames has approx 7 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":13,"end":13}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"911d8c2cd9713eb42fe09220efd48ca7","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::Runner#self.calculate_issues_in_changed_files has approx 19 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":22,"end":22}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"b3db1a66f15bef1e6a1a5d9bbb519f26","type":"issue","check_name":"TooManyStatements","description":"CodeclimateDiff::Runner#self.run_diff_on_branch has approx 7 statements","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff/runner.rb","lines":{"begin":74,"end":74}},"remediation_points":500000,"content":{"body":"A method with `Too Many Statements` is any method that has a large number of lines.\n\n`Too Many Statements` warns about any method that has more than 5 statements. Reek's smell detector for `Too Many Statements` counts +1 for every simple statement in a method and +1 for every statement within a control structure (`if`, `else`, `case`, `when`, `for`, `while`, `until`, `begin`, `rescue`) but it doesn't count the control structure itself.\n\nSo the following method would score +6 in Reek's statement-counting algorithm:\n\n```Ruby\ndef parse(arg, argv, \u0026error)\n  if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n    return nil, block, nil                                         # +1\n  end\n  opt = (val = parse_arg(val, \u0026error))[1]                          # +2\n  val = conv_arg(*val)                                             # +3\n  if opt and !arg\n    argv.shift                                                     # +4\n  else\n    val[0] = nil                                                   # +5\n  end\n  val                                                              # +6\nend\n```\n\n(You might argue that the two assigments within the first @if@ should count as statements, and that perhaps the nested assignment should count as +2.)\n"},"severity":"minor"},
{"engine_name":"reek","fingerprint":"91c4af205f1f773f532585f9dd580548","type":"issue","check_name":"IrresponsibleModule","description":"CodeclimateDiff has no descriptive comment","categories":["Complexity"],"location":{"path":"lib/codeclimate_diff.rb","lines":{"begin":6,"end":6}},"remediation_points":350000,"content":{"body":"Classes and modules are the units of reuse and release. It is therefore considered good practice to annotate every class and module with a brief comment outlining its responsibilities.\n\n## Example\n\nGiven\n\n```Ruby\nclass Dummy\n  # Do things...\nend\n```\n\nReek would emit the following warning:\n\n```\ntest.rb -- 1 warning:\n  [1]:Dummy has no descriptive comment (IrresponsibleModule)\n```\n\nFixing this is simple - just an explaining comment:\n\n```Ruby\n# The Dummy class is responsible for ...\nclass Dummy\n  # Do things...\nend\n```\n"},"severity":"minor"}]
